# eBPF for Beginners: A "Hello World" Guide

Welcome! If you're new to eBPF, this project is the perfect starting point. We've built a simple tool that "spies" on your computer and tells you whenever a command is executed.

## 1. What is eBPF? (The Simple Version)

Imagine your Linux Kernel (the core of your OS) is a highly secure building. Normally, you can't just walk in and change how things work because it's too risky.

**eBPF is like a visitor pass.** It lets you run small, safe programs *inside* the kernel to watch what's happening or even stop things, without needing to rebuild the whole building (kernel).

In this project, we wrote a tiny eBPF program to say "Hello!" every time someone runs a command.

## 2. Prerequisites & Installation (Run This First!)

To make eBPF work, we need some special tools. We ran into a few missing pieces during setup, so here is the **full, error-free installation command** for Ubuntu/Debian:

### Step 1: Install Compilers and Tools
We need `clang` (to compile C code), `llvm`, `bpftool` (to inspect BPF), and `libbpf-dev` (headers).
```bash
sudo apt update
sudo apt install -y clang llvm libbpf-dev linux-tools-$(uname -r) linux-tools-common linux-headers-$(uname -r)
```

### Step 2: Generate `vmlinux.h`
This file is a "dictionary" of kernel types. If you get an error saying `'vmlinux.h' file not found`, run this:
```bash
bpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h
```

### Step 3: Initialize Go Project
If you haven't already:
```bash
go mod init ebpf-hello
go mod tidy
go get github.com/cilium/ebpf/cmd/bpf2go
```

## 3. The Files Explained

Here is what each file in this folder does:

### ğŸ•µï¸ `main.bpf.c` (The Spy)
This is the **C code** that runs inside the kernel.
- It waits for a specific event: `sys_enter_execve` (which happens when a program starts).
- When that event happens, it prints a message to a special kernel log.
- Think of this as a security camera we installed in the hallway.

### ğŸ‘©â€âœˆï¸ `main.go` (The Manager)
This is the **Go code** that runs in your normal terminal (User Space).
- It takes our "Spy" (`main.bpf.c`), compiles it, and loads it into the kernel.
- It makes sure the Spy stays running.
- When you stop this program (Ctrl+C), it removes the Spy.

### ğŸ“– `vmlinux.h` (The Dictionary)
The kernel speaks a complex language with many data types. This file is a huge dictionary that defines all those types so our C code can understand them. We generated this in Step 2.

### ğŸ¤– `gen.go` (The Automation)
This is a tiny file that tells Go: "Hey, when I run `go generate`, please use a tool called `bpf2go` to compile my C code."

### ğŸŒ‰ `bpf_x86_bpfel.go` (The Bridge)
**You don't write this.** It was auto-generated by `bpf2go`. It contains Go functions that wrap our C code, making it easy for `main.go` to talk to `main.bpf.c`.

## 4. How to Run It

1.  **Compile everything:**
    ```bash
    task
    ```
    *Note: If this fails, make sure you ran the `bpftool` command in Step 2!*

2.  **Run the Manager (needs sudo):**
    ```bash
    task run
    ```

3.  **Check your code (Best Practices):**
    ```bash
    task fmt   # Format code
    task lint  # Check for errors
    ```

4.  **See the Spy's reports:**
    Open a *new* terminal window and run:
    ```bash
    sudo cat /sys/kernel/debug/tracing/trace_pipe
    ```
    Now, whenever you run a command in *any* terminal, you'll see a message pop up here!

## 5. DevOps Extras (CI & Docker)

Since you are a DevOps engineer, we added some extra goodies:

### ğŸš€ CI/CD Pipeline
We added a GitHub Action (`.github/workflows/ci.yml`) that automatically:
1.  Installs dependencies.
2.  Compiles the code.
3.  Runs the linter.

## 6. What's Next?
Right now, we just print a static "Hello" message. The next step in learning eBPF would be to read the *actual command name* (like `ls` or `curl`) from the kernel and send it to our Go program.
